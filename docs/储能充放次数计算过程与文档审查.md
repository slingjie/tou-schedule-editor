# 储能充放次数计算过程文档（含原文档审查）

版本：v1.0  
日期：2026-02-17  
编码：UTF-8

---

## 一、算法来源与追溯

### 1.1 原始参考程序

充放次数的计算算法**源自**一个独立的参考程序：

- **参考程序路径**：`D:\Desktop\ai\1028负荷展示和tou配置\参考储能次数测算程序文件夹\1010_储能容量匹配度评估模型_claude`
- **关键参考文件**：
  - `app/services/compute.py` — 核心计算函数 `compute_cycles`、`compute_cycles_window_avg`
  - `app/services/strategy.py` — 时间窗策略→逐日掩码
  - `app/utils/tou.py` — TOU 段与点价序列
  - `app/schemas.py` — 数据模型定义

> **注意**：该参考程序目录已在 `dianjia` 分支中移除以精简仓库体积（见 README 第 330 行），算法已完整迁移到当前项目的 `backend/services/cycles.py` 中。

### 1.2 当前实现位置

| 职责 | 文件 | 核心函数/组件 |
|------|------|---------------|
| 充放次数计算（生产） | `backend/services/cycles.py` 第 777–964 行 | `compute_window_avg_days_with_debug()` |
| 充放次数计算（遗留） | `backend/services/cycles.py` 第 660–774 行 | `compute_window_avg_days()`（未被调用） |
| 策略→掩码 | `backend/services/cycles.py` 第 308–368 行 | `build_daily_cycles_masks()` |
| TOU 价格映射 | `backend/services/cycles.py` 第 397–470 行 | `build_price_series()` |
| 许可功率上限 | `backend/services/cycles.py` 第 131–192 行 | `compute_limit_info()` |
| 后端 API 入口 | `backend/app.py` 第 457–857 行 | `POST /api/storage/cycles` |
| 前端页面 | `components/StorageCyclesPage.tsx` | `StorageCyclesPage` 组件 |
| 前端 API 调用 | `storageApi.ts` | API 封装 |

---

## 二、计算过程详解

### 2.1 总体流程

```
用户输入（储能参数 + 充放策略 + TOU电价 + 负荷数据）
    │
    ▼
① 负荷数据解析 → 15分钟重采样序列（parse_load_series / parse_points_series）
    │
    ▼
② 计费上限计算（compute_limit_info）
    │  ├─ 按需量模式：逐月统计15分钟最大负荷 → limit_kw
    │  └─ 变压器模式：kVA × 功率因数 → limit_kw
    │
    ▼
③ 策略→掩码（build_daily_ops → build_daily_cycles_masks）
    │  ├─ 从24小时格子提取"充/放/待机"连续片段
    │  ├─ 跨午夜拼接（首尾同类合并）
    │  ├─ 小片段阈值过滤（默认30分钟）
    │  └─ 归入 c1/c2 两次循环的 charge/discharge 掩码
    │
    ▼
④ TOU 价格映射（build_price_series）
    │  └─ 按月份格子档位 + 当月价格 → 每个15分钟点的电价
    │
    ▼
⑤ 核心窗口平均计算（compute_window_avg_days_with_debug）☆ 本文重点
    │
    ▼
⑥ 收益计算（compute_profit_summary_step15）
    │
    ▼
⑦ 汇总：日/月/年 cycles + profit → 返回前端
```

### 2.2 核心公式：窗口平均法（window_avg）

#### 第一步：窗口许可功率

对每一天的每个充/放电窗口，选取窗口内所有15分钟点的负荷数据，计算窗口平均负荷：

```
avg_load = mean(窗口内所有15分钟点的 load_kw)
```

**充电许可功率**：

```
allow_ch = max(limit_kw - reserve_charge_kw - avg_load, 0)
```

**放电许可功率**：

```
allow_dis = max(avg_load - reserve_discharge_kw, 0)
```

其中：
- `limit_kw`：计费上限（按需量或变压器容量）
- `reserve_charge_kw`：充电余量（kW）
- `reserve_discharge_kw`：放电余量（kW）

> **注意**：窗口平均法下不受 Pmax（c_rate × capacity）的限制。

#### 第二步：电池侧基数能量

```
base_kwh = allow_kw × hours
```

其中 `hours = 窗口内15分钟点数 × 0.25`

#### 第三步：电网侧能量折算

**physics 口径（默认，物理一致）**：

```
充电：E_in_grid  = base_kwh × DOD / η
放电：E_out_grid = base_kwh × DOD × η
```

**sample 口径（对齐历史样例表格）**：

```
充电：E_in_grid  = base_kwh / DOD × η
放电：E_out_grid = base_kwh / DOD / η
```

其中：
- `η`（eta）：单边效率（single_side_efficiency），默认 0.9
- `DOD`：充放深度（depth_of_discharge）

#### 第四步：满充/满放率

```
full_charge_ratio    = min(E_in_grid / capacity_kwh, 1.0)
full_discharge_ratio = min(E_out_grid / capacity_kwh, 1.0)
```

#### 第五步：单次循环贡献

```
cycle_contrib = min(full_charge_ratio, full_discharge_ratio)
```

#### 第六步：当日充放次数

```
cycles_day = min(fc1_charge, fc1_discharge) + min(fc2_charge, fc2_discharge)
```

即：**第一次循环（c1）的充放取小值 + 第二次循环（c2）的充放取小值**。

### 2.3 手工验算示例

以测试样例 `迁移任务方案/测试样例/样例修改_2025-02-03_96点.csv` 的手算结果为参考：

**输入参数**：
| 参数 | 值 |
|------|-----|
| 变压器容量 | 1250 kVA |
| 功率因素 | 1 |
| 电池容量 | 261 kWh |
| 充放深度（DOD） | 0.9 |
| 单边效率（η） | 0.922 |
| 充电余量 | 250 kW |
| 放电余量 | 50 kW |

**计算过程（sample 口径）**：

| 步骤 | 计算 | 结果 |
|------|------|------|
| C1 充电窗口平均负荷 | — | 95.89 kW |
| C1 放电窗口平均负荷 | — | 119.375 kW |
| C2 充电窗口平均负荷 | — | 190.133 kW |
| C2 放电窗口平均负荷 | — | 173.942 kW |
| C1 可充电量 | (1250×7 - 95.89×7 - 250×7) / 0.9 × 0.922 | 6483.45 kWh |
| C1 满充率 | min(6483.45/261, 1) | **1.0** |
| C1 可放电量 | (119.375×2 - 50×2) / 0.9 / 0.922 | 167.21 kWh |
| C1 满放率 | min(167.21/261, 1) | **0.6406** |
| C2 可充电量 | (1250×3 - 190.133×3 - 250×3) / 0.9 × 0.922 | 2488.99 kWh |
| C2 满充率 | min(2488.99/261, 1) | **1.0** |
| C2 可放电量 | (173.942×6 - 50×6) / 0.9 / 0.922 | 896.18 kWh |
| C2 满放率 | min(896.18/261, 1) | **1.0** |
| **当日充放次数** | min(1, 0.6406) + min(1, 1) | **1.6406** |

### 2.4 DOD 的实际处理

在 `compute_window_avg_days_with_debug` 函数（第 797 行）中：

```python
dod = float(storage_cfg.get("depth_of_discharge", 1.0) or 1.0)
```

直接从用户输入的 `storage_cfg` 中读取 `depth_of_discharge`，默认值为 1.0。

而在 `build_step15_power_series` 函数（第 2145–2148 行）中：

```python
dod_cfg = float(storage_cfg.get("depth_of_discharge", 1.0) or 1.0)
effective_dod = max(0.0, min(dod_cfg, soc_max - soc_min))
```

`effective_dod` 会被 SOC 上下限约束裁剪。两处处理方式不同，详见下方"文档问题"。

---

## 三、调用链路总结

```
前端 StorageCyclesPage 
  → storageApi.ts（封装请求）
    → POST /api/storage/cycles（backend/app.py 第 457 行）
      → cycles_svc.parse_load_series() / parse_points_series()     ← 数据解析
      → cycles_svc.compute_limit_info()                             ← 计费上限
      → cycles_svc.build_daily_ops()                                ← 策略提取
      → cycles_svc.build_daily_cycles_masks()                       ← 掩码构造
      → cycles_svc.build_price_series()                             ← TOU 价格
      → cycles_svc.compute_window_avg_days_with_debug()             ← ☆ 充放次数
      → cycles_svc.compute_profit_summary_step15()                  ← 收益计算
      → cycles_svc.export_excel_report() / export_business_report() ← 报表导出（按需）
    ← StorageCyclesResponse（year/months/days/qc）
```

---

## 四、原文档审查与问题记录

以下是对 4 个相关文档的审查结果，标注了发现的问题。

### 4.1 `迁移任务方案/储能充放次数测算_迁移计划.md`

**问题 1：许可功率公式缺少 `max(..., 0)` 裁剪**

文档第 123–124 行写的是：
```
充电许可：allow_ch = limit_kw - reserve_charge_kw - avg_load
放电许可：allow_dis = avg_load - reserve_discharge_kw
```

但代码实际实现（cycles.py 第 742–746 行、第 838 行）为：
```python
allow = max(0.0, (limit_kw - reserve_ch - avg_load) if is_charge else (avg_load - reserve_dis))
```

即**许可功率不能为负**，需要 `max(0, ...)` 裁剪。文档遗漏了这一关键约束。

---

**问题 2：电网侧能量公式使用了 `sum(allow_ch_clipped * hours)` 写法**

文档第 129–130 行写的是：
```
E_in_grid = sum(allow_ch_clipped * hours) * DOD / η
E_out_grid = sum(allow_dis_clipped * hours) * DOD * η
```

这暗示"逐点求和再折算"，但实际窗口平均法（window_avg）的实现是：
```python
base_kwh = allow_kw × hours  # 窗口平均许可功率 × 窗口总时长
E_in_grid = base_kwh * DOD / η
```

即**先求窗口平均许可功率，再乘以总时长**，而非逐点求和。`sum(allow_ch_clipped * hours)` 的写法更像逐点积分（step_15min）口径，容易造成误解。

---

**问题 3：片段粒度描述与代码不一致**

文档第 99 行写"按 15 分钟粒度遍历 24h"，但实际代码 `_hour_runs_from_ops`（第 282–305 行）是**按小时粒度**提取连段，掩码中存储的是整点小时列表（0–23）。15 分钟粒度仅在后续取负荷数据时使用。

---

**问题 4：术语说明中效率方向表述不准确**

文档第 174 行写：
> η（single_side_efficiency）：充电进电池的能量需乘以 η，放电从电池出来的能量需除以 η 才到电网侧。

但 physics 口径的代码实现（第 753–755 行）是：
```python
E_in_grid = e_in_base * dod / max(eta, 1e-9)   # 充电：÷ η
E_out_grid = e_out_base * dod * eta              # 放电：× η
```

即充电到电网侧是**除以** η（电网需要更多能量才能充入电池），放电到电网侧是**乘以** η（电池出来的能量经过效率损耗）。文档描述的方向**与代码相反**。

---

**问题 5：版本标注过旧**

文档仍标注为"v0.1（草案）"，缺少自迁移完成以来的多次功能更新记录（如收益计算、尖段放电占比、批量容量对比等）。

---

### 4.2 `docs/储能次数计算对话关键内容记录.md`

**问题 6：sample 口径公式与代码实现不完全一致**

文档第 47 行写：
```
sample：充= base/DOD×η；放= base/DOD/η
```

代码第 757–758 行实现为：
```python
E_in_grid = e_in_base / max(dod, 1e-9) * eta       # 充电
E_out_grid = e_out_base / max(dod, 1e-9) / max(eta, 1e-9)  # 放电
```

两者在数学上一致，但文档未说明代码中大量使用的 `max(..., 1e-9)` 防零除保护，可能在 DOD=0 或 η=0 时导致理解偏差。

---

**问题 7：缺少 `compute_window_avg_days` 与 `compute_window_avg_days_with_debug` 关系说明**

文档仅描述了 `window_debug` 报表字段，但未指出：
- 生产环境**只调用** `compute_window_avg_days_with_debug`，`compute_window_avg_days` 是遗留代码且未被调用。
- 两个函数的 DOD 取值方式不同（前者使用外部 `effective_dod` 变量，后者直接从 `storage_cfg` 读取），如果误调用前者可能产生异常。

---

### 4.3 `docs/储能次数计算待办.md`

**问题 8：待办项层次混乱、缺少日期归属**

- 待办列表混合了已完成（`[X]`）、未完成（`[ ]`）和纯文本说明，部分条目（如第 16 行"后续增加收益计算功能"）仅有标题无勾选框。
- 日期标注不规范：仅有 `11-17`、`11-20` 这样的简写，缺少年份，无法明确时间线。
- 第 17 行收益公式描述以对话口吻写成，未整理为正式公式。

---

**问题 9：第 2 行关于 step_15min 的描述与实际实现不一致**

文档写：
> step_15min（SOC 逐点积分）口径计算模式则会将日末配置传送到下一日的日初

但当前代码的 `build_step15_power_series` 函数中，每日 SOC 的起始值是 `initial_soc`（默认 0.05），并未实现跨日 SOC 结转。此功能仍为未完成状态。

---

### 4.4 `docs/1.1新需求储能充放次数测算.md`

**问题 10：仅为对话记录，未整理为正式需求文档**

该文件是 AI 与用户之间的原始对话记录，包含提问与回答混排，缺乏结构化整理。建议：
- 将已确认的问题答案提取为"需求确认清单"。
- 或在文档顶部标注"本文件为历史对话记录，正式需求请参考迁移计划"。

---

**问题 11：参考程序路径在当前仓库中已不存在**

文档第 3 行引用的路径：
```
D:\Desktop\ai\1028负荷展示和tou配置\参考储能次数测算程序文件夹\1010_储能容量匹配度评估模型_claude
```

该目录已从仓库中移除。文档未标注此变更，可能导致新开发者困惑。

---

## 五、代码潜在问题

### 5.1 `compute_window_avg_days` 引用未定义变量

`compute_window_avg_days` 函数第 684 行：
```python
dod = effective_dod
```

`effective_dod` 在该函数内部和模块顶层均未定义。若该函数被调用会抛出 `NameError`。目前因生产代码未调用此函数而未暴露。

**建议**：标记此函数为 `@deprecated` 或直接删除，避免未来误用。

### 5.2 `compute_window_avg_days_with_debug` 与 `build_step15_power_series` 的 DOD 取值不一致

| 函数 | DOD 取值 | 位置 |
|------|----------|------|
| `compute_window_avg_days_with_debug` | `storage_cfg.get("depth_of_discharge", 1.0)` | 第 797 行 |
| `build_step15_power_series` | `min(dod_cfg, soc_max - soc_min)` | 第 2148 行 |

后者会将 DOD 裁剪至不超过 SOC 运行范围（`soc_max - soc_min`），前者不做此裁剪。这意味着如果用户设 DOD=0.9、SOC 范围=0.1~0.8（可用 0.7），窗口平均法仍用 0.9 计算，而 step15 用 0.7 计算，两者结果会有差异。

---

## 六、文档关系总结

| 文档 | 定位 | 状态 |
|------|------|------|
| `docs/1.1新需求储能充放次数测算.md` | 原始需求对话记录 | 历史参考，未整理 |
| `迁移任务方案/储能充放次数测算_迁移计划.md` | 迁移任务方案与接口设计 | 部分过时，有公式误差 |
| `docs/储能次数计算对话关键内容记录.md` | 对话中的关键技术决策与字段说明 | 可用，缺少函数关系说明 |
| `docs/储能次数计算待办.md` | 功能待办清单 | 格式混乱，部分过时 |
| **本文档** | 完整的计算过程文档与文档审查 | **当前版本** |
